---
title: 平板离线缓存开发
date: 2023-04-16 12:11:26
tags: 
- 前端开发
categories:
- 前端
cover: /imgs/img6.jpg
toc: true
---

对于学生端平板应用,在弱网或无网环境下,通过service worker技术缓存静态资源和get请求数据,通过indexDB技术缓存post请求数据,实现离线缓存功能.

<!-- more -->

# 参考资料
1. [Workbox5+Webpack4构建离线应用 - 掘金](https://juejin.cn/post/6844904067345416205?from=search-suggest)
2. [【PWA学习与实践】(3) 让你的WebApp离线可用 - 掘金](https://juejin.cn/post/6844903588691443725)
3. [https://developer.chrome.com/docs/workbox/the-ways-of-workbox/](https://developer.chrome.com/docs/workbox/the-ways-of-workbox/)

# 背景介绍
1. 学生使用平板可能遇到网络不佳问题;
2. 无网环境下希望能查看试题;

# 功能需求
1. 首次进入缓存所有数据;
2. 再次进入直接获取缓存数据;
3. 有网环境判断缓存是否失效决定是否更换缓存;

# 流程
1. 引入webpack,workbox-webpack-plugin包,将workbox引入项目;
2. 生命周期

 - 首次加载
 - 再次进入
 - 更新配置
 - 配置更新后启动

# 应对场景
无网络下:

1. get请求无缓存
2. get请求有缓存
3. post请求无缓存
4. post请求有缓存

# 实现构思
1. 使用serviceWorker技术缓存静态资源和get请求数据;
2. 使用indexDB技术缓存post请求数据;

# 组件实现
1. 入口文件,引入注册文件;

```javascript
import registerSW from '@/workbox/sw-register';

registerSW('sw-redirect.js');
```

2. 注册文件,监听各生命周期,触发对应事件;

```javascript
import { register } from 'register-service-worker';

export const dispatchServiceWorkerEvent = (type,registration)=>{
  let event = new CustomEvent(type, {"detail":registration});
  window.dispatchEvent(event)
}

export default function(swDest) {
  register(`${swDest}`, {
    registered(registration) {
      console.log('service worker(registered) 已注册成功');
      dispatchServiceWorkerEvent('sw.registered', registration);
    },
    updatefound(registration) {
      console.log('service worker(updatefound) 发现更新');
      dispatchServiceWorkerEvent('sw.updatefound', registration);
    },
    cached(registration) {
      console.log('service worker(cached) 已将更新缓存');
      dispatchServiceWorkerEvent('sw.cached', registration);
    },
    ready(registration) {
      console.log('service worker(ready) 已可以使用缓存提供服务');
      dispatchServiceWorkerEvent('sw.ready', registration);
    },
    updated(registration) {
      console.log('service worker(updated) 新配置更新成功,请刷新');
      dispatchServiceWorkerEvent('sw.updated', registration);
    },
    offline() {
      console.log('service worker(offline) 网络连接失败.应用程序正在脱机模式下运行.');
      dispatchServiceWorkerEvent('sw.offline', {});
    },
    error(error) {
      console.log('service worker 注册报错:',error);
      dispatchServiceWorkerEvent('sw.error', error);
    },
  });
}

```

3. 配置文件,包含workbox配置文件

```javascript
import { setCacheNameDetails, clientsClaim, skipWaiting } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'
import { BackgroundSyncPlugin } from 'workbox-background-sync'
import { precacheAndRoute } from 'workbox-precaching/precacheAndRoute'
import { createHandlerBoundToURL } from 'workbox-precaching'
import { NavigationRoute, registerRoute, setDefaultHandler } from 'workbox-routing'
import { StaleWhileRevalidate, NetworkOnly, CacheFirst, NetworkFirst } from 'workbox-strategies'
import { addPostEventListener } from '@/workbox/sw-post'
import Dexie from 'dexie'

/**
 * 缓存信息
 */
const sw_version = 'v1.0.4'
const db_version = 4
// 设置缓存名称
setCacheNameDetails({
  prefix: 'app',
  suffix: sw_version
})

// 更新时自动生效,触发activate;
clientsClaim()
// 预缓存文件，self.__WB_MANIFEST是workbox生成的文件地址数组，项目中打包生成的所有静态文件都会自动添加到里面
precacheAndRoute(self.__WB_MANIFEST || [])

/**
 * 缓存策略
 * Cache First： 先缓存,失败访问网络;
 * Network First: 先访问网络,失败后访问缓存;
 * StaleWhileRevalidate：从缓存中读取资源的同时发送网络请求更新本地缓存
 * 不在同一域下的任何资源，不能使用 Cache only 和 Cache first。
 */


// 单页应用需要应用NavigationRoute进行缓存，此处可自定义白名单和黑名单
const url = ['redirect', 'homework', 'wq-book', 'learning', 'exercise', 'contact']
url.forEach(u => {
  try {
    const handler = createHandlerBoundToURL(`${u}.html`)
    const navigationRoute = new NavigationRoute(handler, {
      denylist: []
    })
    registerRoute(navigationRoute, new CacheFirst({
      cacheName: 'html-cache-' + sw_version,
      plugins: [
        new CacheableResponsePlugin({ statuses: [0, 200] }),  // 请求成功才缓存
        new ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 60 * 24 * 60 * 60 // 设置缓存有效期为60天
        })
      ]
    }))
  } catch (e) {
    console.log(e)
  }
})
// 缓存web的css资源
registerRoute(
  // Cache CSS files
  /.*\.css/,
  // 使用缓存，但尽快在后台更新
  new CacheFirst({
    // 使用自定义缓存名称
    cacheName: 'css-cache-' + sw_version,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),  // 请求成功才缓存
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 24 * 60 * 60 // 设置缓存有效期为60天
      })
    ]
  })
)

// 缓存web的js资源
registerRoute(
  // 缓存JS文件
  /.*\.js$/,
  // 使用缓存，但尽快在后台更新
  new CacheFirst({
    // 使用自定义缓存名称
    cacheName: 'js-cache-' + sw_version,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),  // 请求成功才缓存
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 24 * 60 * 60 // 设置缓存有效期为60天
      })
    ]
  })
)

// 缓存静态资源
registerRoute(
  /\.(?:png|gif|jpg|jpeg|svg|json|ttf|eot|woff|woff2)$/,
  new CacheFirst({
    cacheName: 'static-cache-' + sw_version,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),  // 请求成功才缓存
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 24 * 60 * 60 // 设置缓存有效期为60天
      })
    ]
  })
)

//图片cdn地址，属于跨域资源，我们使用StaleWhileRevalidate缓存策略
registerRoute(/^https:\/\/img.xkw.com\//, new CacheFirst({
  cacheName: 'image-cdn-cache-' + sw_version,
  plugins: [
    new CacheableResponsePlugin({ statuses: [0, 200] }),  // 请求成功才缓存
    new ExpirationPlugin({
      maxEntries: 60,
      maxAgeSeconds: 60 * 24 * 60 * 60 // 设置缓存有效期为60天
    })
  ]
}))

// 接口数据使用服务端数据
registerRoute(/^https:\/\/aizj.sndtech.cn\//, new NetworkFirst({
  cacheName: 'api-cache-' + sw_version,
  networkTimeoutSeconds: 1,
  plugins: [
    new CacheableResponsePlugin({ statuses: [0, 200] }),  // 请求成功才缓存
    new ExpirationPlugin({
      maxEntries: 60,
      maxAgeSeconds: 30 * 24 * 60 * 60 // 设置缓存有效期为30天
    })
  ]
}), 'GET')

// setDefaultHandler(
//   new NetworkFirst({
//     cacheName: 'default-cache-'+version,
//   })
// );


const deleteCache = async (key) => {
  await caches.delete(key)
}

const deleteOldCaches = async () => {
  const exp = new RegExp(sw_version, 'g')
  const keyList = await caches.keys()
  const cachesToDelete = keyList.filter((key) => !exp.test(key))
  const db = new Dexie('post_cache')
  db.delete()
  await Promise.all(cachesToDelete.map(deleteCache))
}

// 只有sw文件修改才会重新安装,当旧版本不在使用sw才会触发激活;
addEventListener('activate', (event) => {
  console.log('service worker(activate) 激活完成.')
  event.waitUntil(deleteOldCaches())
})

// service worker通过message和主线程通讯
addEventListener('message', event => {
  const replyPort = event.ports[0]
  const message = event.data
  console.log('service worker 监听message')
  if (replyPort && message && message.type === 'skip-waiting') {
    event.waitUntil(
      skipWaiting()
    )
  }
})

addPostEventListener(db_version)

```

4. indexDB缓存方法,用于缓存post请求数据;

```javascript
import Dexie from 'dexie'

// 通过拦截post请求,请求成功则返回原数据,失败则数据库查询;
export const addPostEventListener = (version) => {
  addEventListener('fetch', function(event) {
    if (event.request.method === 'POST') {
      let db = new Dexie('post_cache')
      db.version(version).stores({
        post_cache: 'key,response,timestamp'
      })
      event.respondWith(
        fetch(event.request.clone())
          .then(function(response) {
            cachePut(event.request.clone(), response.clone(), db.post_cache)
            return response
          })
          .catch(function(e) {
            console.log('sw:fetch error', e)
            // 未命中缓存返回503
            return cacheMatch(event.request.clone(), db.post_cache)
          })
      )
    }
  })
}

/**
 * Serializes a Request into a plain JS object.
 *
 * @param request
 * @returns Promise
 */
function serializeRequest(request) {
  var serialized = {
    url: request.url,
    headers: serializeHeaders(request.headers),
    method: request.method,
    mode: request.mode,
    credentials: request.credentials,
    cache: request.cache,
    redirect: request.redirect,
    referrer: request.referrer
  }

  if (request.method !== 'GET' && request.method !== 'HEAD') {
    return request.clone().text().then(function(body) {
      serialized.body = body
      return Promise.resolve(serialized)
    }).catch(e => {
      console.log(e)
    })
  }
  return Promise.resolve(serialized)
}

/**
 * Serializes a Response into a plain JS object
 *
 * @param response
 * @returns Promise
 */
function serializeResponse(response) {
  var serialized = {
    headers: serializeHeaders(response.headers),
    status: response.status,
    statusText: response.statusText
  }

  return response.clone().text().then(function(body) {
    serialized.body = body
    return Promise.resolve(serialized)
  })
}

/**
 * Serializes headers into a plain JS object
 *
 * @param headers
 * @returns object
 */
function serializeHeaders(headers) {
  var serialized = {}
// `for(... of ...)` is ES6 notation but current browsers supporting SW, support this
// notation as well and this is the only way of retrieving all the headers.
  for (var entry of headers.entries()) {
    serialized[entry[0]] = entry[1]
  }
  return serialized
}

/**
 * Creates a Response from it's serialized version
 *
 * @param data
 * @returns Promise
 */
function deserializeResponse(data) {
  return Promise.resolve(new Response(data.body, data))
}

/**
 * Saves the response for the given request eventually overriding the previous version
 *
 * @param data
 * @returns Promise
 */
function cachePut(request, response, store) {
  var key, data
  getPostId(request.clone())
    .then(function(id) {
      key = JSON.stringify(id)
      return serializeResponse(response.clone())
    })
    .then(function(serializedResponse) {
      data = serializedResponse
      var entry = {
        key: key,
        response: data,
        timestamp: Date.now()
      }
      store
        .add(entry)
        .catch(function(error) {
          store.update(entry.key, entry)
        })
    })
    .catch(e => {
      console.log(e)
    })
}

/**
 * Returns the cached response for the given request or an empty 503-response for a cache miss.
 *
 * @param request
 * @param store
 * @return Promise
 */
function cacheMatch(request,store) {
  return getPostId(request.clone())
    .then(function(id) {
      return store.get(JSON.stringify(id))
    }).then(function(data) {
      if (data) {
        return deserializeResponse(data.response)
      } else {
        return new Response('', { status: 503, statusText: 'Service Unavailable' })
      }
    })
}

/**
 * Returns a string identifier for our POST request.
 *
 * @param request
 * @return Promise
 */

function getPostId(request) {
  return serializeRequest(request.clone())
}

```

## 问题
1. 不同设备缓存上限不同,平板20M文件缓存导致会死机,需要定期清理;

# 注意
1. service worker 只能运行在https下;
2. service worker无法缓存post请求;
3. 本地https://localhost:3000会因为ssl证书检测错误报错,通过`.\chrome.exe --ignore-certificate-errors`关闭浏览器ssl检测,方便调试;

