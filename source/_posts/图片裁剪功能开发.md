---
title: 图片裁剪功能开发
date: 2023-06-16 12:11:26
tags: 
- 前端开发
categories:
- 前端
cover: /imgs/tpcj2.png
toc: true
---

二次开发elementUI图片预览功能,使其支持图片裁剪功能;
利用cropperjs库实现图片裁剪功能,提供旋转,取消,提交,帮助功能;
利用ai图像识别,实现自动裁剪功能,提高识别准确率;

<!-- more -->

## 背景介绍
1. 教师通过上传试卷图片将试卷中试题加入到系统的教辅题库中,方便之后的作业选题;
2. 识别试题通过学科网图像识别获取对应题库中的试题;

## 功能需求
1. 通过试题裁剪功能有效裁剪单个试题,提高识别准确率,将学科网题库中对应试题加入AI助手数据库中;
2. 裁剪后需缓存数据,下次开启裁剪,图片显示对应裁剪框;

## 实现构思
1. 参考element图片组件样式展示图片,提供旋转,取消,提交,帮助功能;
2. 使用cropperjs库实现裁剪功能,自定义插入裁剪按钮优化体验;

## 组件实现
### 样式实现
1. 将组件放在body下实现全局弹窗;
2. 隐藏canvas和按钮,优化渲染,需要时直接复制或展示;

```html
<teleport to="body">
  <transition name="imgCut-fade" appear>
    <div ref="wrapper" class="ImgCut" :tabindex="-1" :style="{ zIndex: computedZIndex }">
      <div class="mask"></div>
      <!-- 关闭 -->
      <span class="btn close" @click="hide">
        <el-icon><Close /></el-icon>
      </span>
      <!-- 操作 -->
      <div class="btn actions">
        <div class="actions__inner">
          <el-icon class="icon" @click="handleActions('help')">
            <Warning />
          </el-icon>
          <el-icon class="icon" @click="handleActions('anticlockwise')">
            <RefreshLeft />
          </el-icon>
          <el-icon class="icon" @click="handleActions('clockwise')">
            <RefreshRight />
          </el-icon>
          <el-icon class="icon" color="#ff4040" @click="handleActions('cancel')">
            <CircleClose />
          </el-icon>
          <el-icon class="icon" color="#30c9a1" @click="handleActions('cut')">
            <CircleCheck />
          </el-icon>
        </div>
      </div>
      <!-- 图片 -->
      <div class="canvas">
        <canvas id="imgCanvas" ref="canvasRefs" style="display: none"></canvas>
        <div class="cropper-action" style="display: none">
          <el-icon class="cropper-action__btn icon" color="#ff4040" id="cropper-cancel"
            ><CircleClose
               /></el-icon>
          <el-icon class="cropper-action__btn icon" color="#30c9a1" id="cropper-submit"
            ><CircleCheck
               /></el-icon>
        </div>
      </div>
    </div>
  </transition>
</teleport>
```

### 逻辑实现
1. 初始化获取缓存并依次实例化图片,画布,裁剪对象,再执行绘制裁剪框;
2. 裁剪时,通过裁剪对象获取裁剪图片信息并进行信息转化,将其存入裁剪数组,同时绘制边框重新渲染图片,返回数据给上层组件;

```vue

<script lang="ts" setup name="img-cut">
import Cropper from 'cropperjs'
import 'cropperjs/dist/cropper.css'
import { imgCutProps, imgCutEmits, ImageViewerAction } from './ImgCut'
import { isNull, isNumber } from '@/utils/is'
// import { useZIndex } from 'element-plus'
import {
  Close,
  RefreshLeft,
  RefreshRight,
  Warning,
  CircleCheck,
  CircleClose
} from '@element-plus/icons-vue'
import { reject } from 'lodash-es'

const props = defineProps(imgCutProps)
const emit = defineEmits(imgCutEmits)
// const { nextZIndex } = useZIndex()
const imgBase64Data = ref('')
const canvasRefs = ref<HTMLCanvasElement>()
const imgCropper = ref<Cropper | null>(null)
const cutImgs = ref<any[]>([])
const dialogVisible = ref(false)

const computedZIndex = computed(() => {
  return isNumber(props.zIndex) ? props.zIndex : 2005
})

const init = async () => {
  await initCanvas()
  initCropper()
  // 裁剪数组克隆
  cutImgs.value = [...props.cutImgs]
  // 存在缓存则裁剪获取图片base64
  initCut()
}
// 初始化图片和canvas
const initCanvas = () => {
  return new Promise((resolve) => {
    const canvas = document.getElementById('imgCanvas')
    const ctx = canvas.getContext('2d')
    imgBase64Data.value = props.img
    const img = new Image()
    img.src = imgBase64Data.value
    img.onload = function () {
      canvas.width = img.width
      canvas.height = img.height
      ctx.drawImage(img, 0, 0, img.width, img.height)
      resolve(canvas)
    }
  })
}
// 初始化裁剪对象
const initCropper = () => {
  const canvasEl = unref(canvasRefs)
  if (!canvasEl) {
    return
  }
  imgCropper.value = new Cropper(canvasEl, {
    viewMode: 1,
    dragMode: 'crop',
    preview: '.before',
    background: false,
    autoCrop: false,
    autoCropArea: 0.8,
    modal: false,
    ready: () => {
      addActionEl()
    }
  })
}
// 在裁剪框中添加操作按钮
const addActionEl = async () => {
  await nextTick()
  const cropperEl = document.querySelector('.cropper-crop-box')
  const cropperActEl = document.querySelector('.cropper-action')
  if (!cropperEl) return
  if (!cropperActEl) return
  const clonedNode = cropperActEl.cloneNode(true)
  cropperEl.insertAdjacentElement('beforeend', clonedNode)
  clonedNode.style.display = 'flex'
  const submitBtn = document.getElementById('cropper-submit')
  const cancelBtn = document.getElementById('cropper-cancel')
  submitBtn?.addEventListener('click', handleCut)
  cancelBtn?.addEventListener('click', () => {
    imgCropper.value.clear()
  })
}
// 如果图片存在裁剪缓存,绘制裁剪边框
const initCut = () => {
  cutImgs.value.forEach((i) => {
    drawImg(i.cutData)
  })
  // 替换旧画布
  imgCropper.value?.replace(unref(canvasRefs).toDataURL('image/png'), true)
  imgCropper.value?.clear()
}
/** 操作 **/
const handleActions = (action: ImageViewerAction) => {
  switch (action) {
    case 'help':
      dialogVisible.value = true
      break
    case 'anticlockwise':
      imgCropper.value?.rotate(-90)
      break
    case 'clockwise':
      imgCropper.value?.rotate(90)
      break
    case 'cut':
      handleSubmit()
      break
    case 'cancel':
      hide()
      break
  }
}
const handleDialogClose = () => {
  dialogVisible.value = false
}
/** 裁剪 **/
const handleCut = () => {
  if (isNull(imgCropper.value)) {
    return
  }
  // 裁剪数组增加元素
  let img = imgCropper.value
    .getCroppedCanvas({
      imageSmoothingQuality: 'high'
    })
    .toDataURL('image/png')
  // 保存裁剪位置信息,方便之后做撤销功能
  let cutData = imgCropper.value.getData()
  // 将旋转后的坐标转换为原始坐标
  if (cutData.rotate < 0) {
    cutData.rotate += 360
  }
  let cutInfo = {
    x: cutData.x,
    y: cutData.y,
    width: cutData.width,
    height: cutData.height
  }
  let imgInfo = {
    w: imgCropper.value.getImageData().naturalWidth,
    h: imgCropper.value.getImageData().naturalHeight
  }
  switch (cutData.rotate / 90) {
    case 0:
      break
    case 1:
      cutInfo.x = cutData.y
      cutInfo.y = imgInfo.h - cutData.x - cutData.width
      cutInfo.width = cutData.height
      cutInfo.height = cutData.width
      break
    case 2:
      cutInfo.x = imgInfo.w - cutData.x - cutData.width
      cutInfo.y = imgInfo.h - cutData.y - cutData.height
      break
    case 3:
      cutInfo.x = imgInfo.w - cutData.y - cutData.height
      cutInfo.y = cutData.x
      cutInfo.width = cutData.height
      cutInfo.height = cutData.width
      break
  }
  cutImgs.value.push({
    img,
    cutData: cutInfo
  })
  // 将裁剪元素边框绘制到画布
  drawImg(cutInfo)
  // 替换旧画布
  imgCropper.value?.replace(unref(canvasRefs).toDataURL('image/png'), true)
  imgCropper.value?.clear()
}

// 裁剪边框绘制
const drawImg = (info) => {
  const ctx = unref(canvasRefs).getContext('2d')
  if (isNull(ctx)) return
  ctx.strokeStyle = '#ff4040'
  ctx.lineWidth = 3
  ctx.setLineDash([20])
  ctx.strokeRect(info.x, info.y, info.width, info.height)
}
const handleSubmit = () => {
  let info = {
    img: unref(canvasRefs).toDataURL('image/png'),
    cutArr: cutImgs.value
  }
  emit('onSubmit', info)
  hide()
}
const hide = () => {
  // 销毁实例
  if (imgCropper.value) {
    imgCropper.value.destroy()
  }
  emit('close')
}

onMounted(() => {
  init()
})
</script>
```

## 总结
1. 分解各个对象的关系和顺序,掌握裁剪库包含的方法;

## bug处理
1. 通过canvas进行裁剪,传入坐标和高宽,输出对应图片base64; 利用方法: `drawImage()``toDataURL()`;出现裁剪图片尺寸错误问题,最终解决方案是发现需要将canvas的宽高设置为同等大小;

## 成果

<div class="justified-gallery">
<img src="/imgs/tpcj1.png" alt="" />
<img src="/imgs/tpcj2.png" alt="" />
</div>

