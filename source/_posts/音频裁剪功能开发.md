---
title: 音频裁剪功能开发
date: 2023-07-28 12:11:26
tags:
- 前端开发
categories:
- 前端
cover: /imgs/ypcj1.png
toc: true
---

针对英语听力题型需求,将整卷试题音频裁剪为单个试题音频;
结合ai语音识别技术,开发音频裁剪功能,实现音频文件的裁剪和导出功能.

<!-- more -->

## 背景介绍
题库录入需要满足英语听力题型需求,练习册配套听力文件为一整套试题音频,因此需要裁剪工具将其裁剪为单个试题音频;

## 功能需求
1. 上传音频文件
2. 试听音频文件
3. 音频转写,通过文本内容快速定位切割点
4. 可手动输入切割点,进行音频文件裁剪
4. 通过切割点将音频文件多段裁剪,打包导出

## 实现构思
1. 引用 'browser-md5-file', 'sha1', 'vue3-aplayer', 'jszip'库;
2. 利用语音识别技术,将音频文件转写为文本内容;
3. 对文本内容中特定关键词进行标记,作为音频裁剪点,添加换行符;
4. 通过音频裁剪点,将音频文件裁剪为多段音频文件,打包导出;
## 组件实现
### 裁剪音频
```javascript
async function cutAudio(file, cutTimeList) {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)()
    // 读取文件
    const fileReader = new FileReader()
    fileReader.readAsArrayBuffer(file)
    const arrayBuffer = await new Promise((resolve) => {
        fileReader.onloadend = () => resolve(fileReader.result)
    })
    // 解码音频数据
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer)
    const zip = new JSZip()
    // 裁剪音频数据
    for (let i = 0; i < cutTimeList.length; i++) {
        const start = i > 0 ? cutTimeList[i - 1] : 0
        const end = cutTimeList[i]
        const cutAudioBlob = cutAudioBuffer(audioBuffer, start, end, audioContext)
        zip.file(`audio${i + 1}.wav`, cutAudioBlob)
    }
    const zipBlob = await zip.generateAsync({ type: 'blob' })
    const link = document.createElement('a')
    link.href = URL.createObjectURL(zipBlob)
    link.download = '裁剪音频.zip'
    link.click()
    message.success('导出成功!')
}
function cutAudioBuffer(audioBuffer, start, end, audioContext) {
  const numberOfChannels = audioBuffer.numberOfChannels
  const sampleRate = audioBuffer.sampleRate
  const length = Math.floor((end - start) * sampleRate)
  const newBuffer = audioContext.createBuffer(numberOfChannels, length, sampleRate)
  for (let i = 0; i < numberOfChannels; i++) {
    const channelData = audioBuffer.getChannelData(i)
    const newChannelData = newBuffer.getChannelData(i)
    for (let j = 0; j < length; j++) {
      newChannelData[j] = channelData[Math.floor((start + j / sampleRate) * sampleRate)]
    }
  }

  return bufferToWave(newBuffer, length)
}
function bufferToWave(abuffer, len) {
  var numOfChan = abuffer.numberOfChannels,
    length = len * numOfChan * 2 + 44,
    buffer = new ArrayBuffer(length),
    view = new DataView(buffer),
    channels = [],
    i,
    sample,
    offset = 0,
    pos = 0

  // write WAVE header
  // "RIFF"
  setUint32(0x46464952)
  // file length - 8
  setUint32(length - 8)
  // "WAVE"
  setUint32(0x45564157)
  // "fmt " chunk
  setUint32(0x20746d66)
  // length = 16
  setUint32(16)
  // PCM (uncompressed)
  setUint16(1)
  setUint16(numOfChan)
  setUint32(abuffer.sampleRate)
  // avg. bytes/sec
  setUint32(abuffer.sampleRate * 2 * numOfChan)
  // block-align
  setUint16(numOfChan * 2)
  // 16-bit (hardcoded in this demo)
  setUint16(16)
  // "data" - chunk
  setUint32(0x61746164)
  // chunk length
  setUint32(length - pos - 4)

  // write interleaved data
  for (i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i))

  while (pos < length) {
    // interleave channels
    for (i = 0; i < numOfChan; i++) {
      // clamp
      sample = Math.max(-1, Math.min(1, channels[i][offset]))
      // scale to 16-bit signed int
      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0
      // write 16-bit sample
      view.setInt16(pos, sample, true)
      pos += 2
    }
    // next source sample
    offset++
  }

  // create Blob
  return new Blob([buffer], { type: 'audio/wav' })

  function setUint16(data) {
    view.setUint16(pos, data, true)
    pos += 2
  }

  function setUint32(data) {
    view.setUint32(pos, data, true)
    pos += 4
  }
}
```

### 导出音频
```javascript
const exportZip = async () => {
  // 将音频文件多段裁剪并导出
  let checkWordList = wordInfo.wordList.filter((i) => i['checked'] == 2)
  if (checkWordList.length == 0) {
    message.error('请先在文本中标记需要裁剪分割的位置！')
    return
  }
  let cutTimeList = checkWordList.map((i) => {
    return i['start'] / 1000
  })
  contentLoading.value = true
  await cutAudio(uploadProp.data, cutTimeList)
  contentLoading.value = false
}
```

## 总结
1. file类型文件在进行操作前,需要通过readAsArrayBuffer()转换类型;

## 成果

<div class="justified-gallery">
<img src="/imgs/ypcj1.png" alt="" />
</div>


