---
title: 柜机模版开发
date: 2020-05-10 12:11:26
tags: 
- 前端开发
categories:
- 前端
cover: /imgs/guiji1.png
toc: true
---

快递柜样式实行个性化定制,实现对柜机模板的增删改查，以便在网点柜机添加时能选择不同柜机模板。

<!-- more -->

## 背景介绍
快递柜样式实行个性化定制，因此管理后台需添加 **柜机模板** 功能，用于实现对柜机模板的增删改查，以便在网点柜机添加时能选择不同柜机模板。

## 功能需求
1. 通过可视化柜机模板展示柜机当前格口组成分布；
2. 通过树形图实现用户对格口的拆分，添加与删除；
3. 通过点击单个格口实现选中操作功能；
4. 柜机模板的组成分布及格口信息作为参数发送到服务器接口;

## 实现构思
1. 柜机模板显示通过嵌套对象方便渲染。`思考问题：修改一个子节点是否会造成父节点的重复渲染；`
2. 格口信息，柜机展示，树形图三者数据统一在上层，上层数据结构转换为api参数；`思考问题：多种数据结构如何转换；`
3. 统一数据向下传递，模块操作向上层发出事件；`思考问题：统一数据和事件方法如何编写；`

## 组件实现
### <font style="color:rgb(36, 41, 46);">cabTemp:</font>
1. <font style="color:rgb(36, 41, 46);">柜机容器组件：展示柜机全局信息，遍历格口树。</font>
2. <font style="color:rgb(36, 41, 46);">行列样式组件：通过行列标识展示当前排版。</font>
3. <font style="color:rgb(36, 41, 46);">格口样式组件：渲染格口样式，绑定格口选中事件,将点击节点key传入vuex中保存。</font>

### <font style="color:rgb(36, 41, 46);">cabTree:</font>
1. <font style="color:rgb(36, 41, 46);">使用el-tree渲染，数据通过vuex共享获取.</font>
2. <font style="color:rgb(36, 41, 46);">添加,删除节点事件通过触发vuex的actions改变,参数传入节点key,vuex通过key获取节点执行操作。</font>
3. <font style="color:rgb(36, 41, 46);">点击节点事件和格口组件点击相同,通过传入vuex参数key,让vuex中currentGrid保存当前选中节点.</font>

### <font style="color:rgb(36, 41, 46);">cabGridInfo:</font>
1. <font style="color:rgb(36, 41, 46);">当前选中节点通过vuex获取,展示选中节点信息.</font>
2. <font style="color:rgb(36, 41, 46);">提供修改信息操作,操作传入vuex中修改.</font>



```javascript
        removeNode(state, value) { // 删除当前node,将父节点改为展示节点
            let {
                node,
                preNode
            } = getNodeByKey(state.tree, value.data['v_key']);
            let index = node['v_key'].split('-').reverse()[0];
            preNode['children'].splice(index, 1);
            if (preNode['children'].length > 0) {
                perOrder(preNode, preNode['v_key'])
            } else {
                preNode['type'] = '3';
            }
        },
        addNode(state, value) { // 在一个container中再次添加node
            let {
                node,
                preNode
            } = getNodeByKey(state.tree, value.data['v_key']);
            node.type = preNode.type == '1' ? '2' : '1' //上个格口是横向则这个格口纵向
            let length = node['children'].length;
            node['children'].push({
                level: node.level + 1,
                data: {
                    lockDrivePlatesNo: null,
                    lockDrivePlatesPortNo: null,
                    type: null,
                },
                type: '3',
                v_key: node.v_key + '-' + length,
                children: [],
            })
        },
        
```



## 总结
当遇到复杂需求，思考如何拆分功能，将多个功能拆分组件实现，再思考每个组件所需要的数据格式和内容以及组件通信方式，确定公共变量和方法，最后获得清晰的代码实现；

## 成果

<div class="justified-gallery">
<img src="/imgs/guiji1.png" alt="" />
<img src="/imgs/guiji2.png" alt="" />
</div>
